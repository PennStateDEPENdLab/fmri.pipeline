#' helper function to generate confounds txt file for inclusion as additional regressors
#'
#' @details This function checks for whether an l1 confounds file already exists in the expected location.
#'   If it does not, the l1 confounds file will be generated according to the $confound_settings$l1_confound_regressors
#'   variable. If that is NULL, no confounds will be created.
#'
#' Confounds are generated by looking for motion parameters based on $confound_settings$motion_params_file and
#'   $confound_settings$confound_input_file. These are integrated, then columns that are requested in
#'   $confound_settings$l1_confound_regressors are written to a text file in the analysis subfolder for each subject
#'
#' Likewise, any run-level exclusions are tested according to $confound_settings$exclude_run. This should be a
#'   quoted expression that can tested against the confounds data.frame such that a single TRUE/FALSE is returned
#'   indicating whether a run is excluded (TRUE) or retained (FALSE) for higher-level analyses.
#'
#' @return a list containing: confounds=<location of l1 confounds file>, exclude_run=<TRUE/FALSE denoting run exclusion,
#'   exclude_data=<location of file containing columns used to calculate run exclusion>
#' @param id The subject id
#' @param session The session number
#' @param run_number The run number
#' @param gpa a \code{glm_pipeline_arguments} object containing pipeline specification
get_l1_confounds <- function(id = NULL, session = NULL, run_number = NULL, gpa, drop_volumes=0L, last_volume=NULL, demean=TRUE) {
  if (checkmate::test_null(id)) { stop("get_l1_confounds requires a specific id for lookup") }
  checkmate::assert_integerish(session, null.ok=TRUE)
  if (is.null(session)) session <- 1
  checkmate::assert_integerish(run_number, lower=1, null.ok = FALSE)
  checkmate::assert_class(gpa, "glm_pipeline_arguments")
  checkmate::assert_integerish(drop_volumes, lower = 0)
  checkmate::assert_integerish(last_volume, null.ok = TRUE)

  lg <- lgr::get_logger("glm_pipeline/l1_setup")

  rinfo <- gpa$run_data %>% dplyr::filter(id == !!id & session == !!session & run_number == !!run_number)
  if (nrow(rinfo) > 1L) {
    print(rinfo)
    lg$error("Multiple matches for a single run in get_l1_confounds.")
    return(NULL)
  } else if (nrow(rinfo) == 0L) {
    lg$error("Unable to locate a record in gpa$run_data for id %s, session %s, run_number %s.", id, session, run_number)
    return(NULL)
  }

  # Park these in an analysis-level subfolder, not a particular model, since they are re-used across models.
  # Note: normalizePath will fail to evaluate properly if directory does not exist
  analysis_outdir <- get_l1_directory(id=id, session=session, gpa=gpa, create_if_missing = TRUE)

  # determine whether we should be returning information about l1 confound regressors
  # and whether this information has already been calculated
  generate_l1_confounds <- FALSE
  if (is.null(gpa$confound_settings$l1_confound_regressors)) {
    # no confounds requested
    expected_l1_confounds_file <- NA_character_
  } else {
    expected_l1_confounds_file <- file.path(analysis_outdir, paste0("run", run_number, "_l1_confounds.txt"))
    if (!file.exists(expected_l1_confounds_file)) {
      lg$debug("Expected confounds file file does not exist: %s.", expected_l1_confounds_file)
      generate_l1_confounds <- TRUE
    }
  }

  # determine whether we should be returning information about run exclusions
  # and whether this information has already been calculated
  generate_run_exclusion <- FALSE
  if (is.null(gpa$confound_settings$exclude_run)) {
    # no basis for exclusion (all runs okay)
    exclude_file <- NA_character_
    exclude_data_file <- NA_character_
    exclude_run <- FALSE
  } else {
    exclude_file <- file.path(analysis_outdir, paste0("run", run_number, "_l1_exclude.txt"))
    exclude_data_file <- file.path(analysis_outdir, paste0("run", run_number, "_l1_exclude_data.txt"))
    if (file.exists(exclude_data_file)) {
      exclude_run <- as.logical(readLines(con = exclude_file, n = 1L))
    } else {
      lg$debug("Expected exclude data file does not exist: %s.", exclude_data_file)
      exclude_run <- NULL
      generate_run_exclusion <- TRUE
    }
  }

  # If both run exclusion and l1 confounds exist, just the precalculated information
  if (!(generate_l1_confounds || generate_run_exclusion)) {
    if (!is.na(expected_l1_confounds_file)) lg$debug("Returning extant file: %s in get_l1_confounds", expected_l1_confounds_file)
    if (!is.na(exclude_data_file)) lg$debug("Returning extant run exclusion: %s in get_l1_confounds", exclude_data_file)

    return(list(confounds = expected_l1_confounds_file, exclude_run = exclude_run, exclude_data = exclude_data_file))
  }

  #read external confounds file
  confound_df <- NULL
  if (isTRUE(rinfo$confound_input_file_present[1])) {
    cfile <- get_mr_abspath(rinfo, "confound_input_file")[1]
    lg$debug("Reading confound file: %s", cfile)
    confound_df <- tryCatch(data.table::fread(cfile, data.table=FALSE), error = function(e) {
      lg$error("Failed to read confound file: %s with error %s", cfile, as.character(e))
      return(NULL)
    })

    if (!is.null(gpa$confound_settings$confound_input_colnames) && !is.null(confound_df)) {
      if (length(gpa$confound_settings$confound_input_colnames) != ncol(confound_df)) {
        lg$warn(
          "Mismatch in number of columns in confound file: %s relative to $confound_settings$confound_input_colnames",
          rinfo$confound_input_file[1]
        )
      }
      data.table::setnames(confound_df, gpa$confound_settings$confound_input_colnames)
    }

    confound_df <- confound_df[(1 + drop_volumes):last_volume, ]
  }

  #read motion parameters file
  motion_df <- NULL
  if (isTRUE(rinfo$motion_params_present[1])) {
    mfile <- get_mr_abspath(rinfo, "motion_params")[1]
    lg$debug("Reading motion file: %s", mfile)

    # Note: Avoid demeaning columns within generate_motion_regressors so that calculated regressors do not
    # change scale prior to testing the run exclusion criteria below. Demeaning can be applied safely thereafter.
    motion_df <- tryCatch({
      generate_motion_regressors(
        mfile,
        col.names = gpa$confound_settings$motion_params_colnames,
        regressors = gpa$confound_settings$all_confound_columns,
        drop_volumes = drop_volumes, last_volume = last_volume, demean=FALSE
      )}, error = function(e) {
      lg$error("Failed to read motion file: %s with error %s", rinfo$motion_params[1], as.character(e))
      return(NULL)
    })

    if (!is.null(gpa$confound_settings$motion_params_colnames) && !is.null(motion_df)) {
      if (length(gpa$confound_settings$motion_params_colnames) != ncol(motion_df)) {
        lg$warn(
          "Mismatch in number of columns in confound file: %s relative to $confound_settings$confound_input_colnames",
          mfile
        )
      }
      data.table::setnames(motion_df, gpa$confound_settings$motion_params_colnames)
    }

  }

  # combine motion and confound files
  if (is.null(motion_df) && is.null(confound_df)) {
    lg$info("Neither confounds nor motion parameters are available for %s", rinfo$run_nifti[1L])
    return(NULL)
  } else if (is.null(motion_df)) {
    confounds <- confound_df
  } else if (is.null(confound_df)) {
    confounds <- motion_df
  } else {
    if (nrow(motion_df) != nrow(confound_df)) {
      lg$error("Number of rows in motion_df is: %d and in confound_df is %d. Cannot combine", nrow(motion_df), nrow(confound_df))
      return(NULL)
    } else {
      # prefer confound_df as authoritative in cases where motion_df has overlapping columns
      overlap_names <- intersect(names(motion_df), names(confound_df))
      if (length(overlap_names) > 0L) {
        lg$info(
          "Motion parameters have overlapping columns with confounds file: %s. Preferring confounds to motion params",
          rinfo$confound_input_file[1L]
        )
        lg$info("Overlap: %s", overlap_names)
        data.table::setnames(motion_df, old = overlap_names, new = paste0(overlap_names, ".mot"))
      }

      confounds <- dplyr::bind_cols(confound_df, motion_df)
    }
  }

  # calculate whether to retain or exclude this run
  if (!is.null(gpa$confound_settings$exclude_run)) {
    if (!all(gpa$confound_settings$run_exclusion_columns %in% names(confounds))) {
      lg$warn("Missing exclusion columns for subject: %s, session: %s", rinfo$id[1L], rinfo$session[1L])
      lg$warn("Column: %s", setdiff(gpa$confound_settings$run_exclusion_columns, names(confounds)))
      lg$warn("We will exclude this run from analysis until this is resolved!")
      exclude_run <- TRUE
    } else {
      # evaluate run exclusion expression
      exclude_run <- tryCatch(with(confounds, eval(parse(text = gpa$confound_settings$exclude_run))),
        error = function(e) {
          lg$error(
            "Problem evaluating run exclusion for subject: %s, session: %s, run_number: %s, expr: %s",
            id, session, run_number,
            gpa$confound_settings$exclude_run
          )
          lg$error("Defaulting to exclusion of run.")
          return(TRUE)
        }
      )

      if (length(exclude_run) > 1L) {
        lg$error("Run exclusion expression %s returned %d results!", gpa$confound_settings$exclude_run, length(exclude_run))
        lg$error("Modify the expression so that it returns a single TRUE/FALSE.")
        lg$error("Defaulting to exclusion of run.")
        exclude_run <- TRUE
      }
    }

    # write the exclusion basis to file
    exclude_df <- confounds[, intersect(gpa$confound_settings$run_exclusion_columns, names(confounds)), drop=FALSE]
    write.table(exclude_df, file = exclude_data_file, row.names = FALSE, col.names = TRUE)
  } else {
    exclude_run <- FALSE
  }

  # trim l1 confounds to only those requested
  if (!all(gpa$confound_settings$l1_confound_regressors %in% names(confounds))) {
    lg$warn("Missing confound columns for subject: %s, session: %s", rinfo$id[1L], rinfo$session[1L])
    lg$warn("Column: %s", setdiff(gpa$confound_settings$l1_confound_regressors, names(confounds)))

    confounds <- confounds[, intersect(gpa$confound_settings$l1_confound_regressors, names(confounds))]
  }

  # demean confound regressors, if requested (usually a good idea)
  if (isTRUE(demean)) {
    lg$debug("Demeaning columns of l1 confounds matrix: %s", expected_l1_confounds_file)
    confounds <- as.data.frame(apply(confounds, 2, function(x) {
      x - mean(x, na.rm = TRUE)
    }))
  }

  lg$debug("Writing l1 confounds to file: %s", expected_l1_confounds_file)
  write.table(confounds, file = expected_l1_confounds_file, row.names = FALSE, col.names = FALSE)
  writeLines(as.character(exclude_run), con = exclude_file)

  return(list(confounds = expected_l1_confounds_file, exclude_run = exclude_run, exclude_data = exclude_data_file))
}
