#' note: this is a small adapation from the original fslSCEPTICModel to avoid use of the clockfit objects and to move to the
#' simpler build_design_matrix approach and the use of the trial_statistics csv files from vba_fmri
#'
#' @param d_obj a single-subject design matrix object generated by build_design_matrix
#' @param gpa a gpa (glm_pipeline_arguments) object generated by setup_glm_pipeline
#' @param model_name a string indicating the model name within \code{gpa} to setup. If
#'   you wish to setup multiple models, this is handled upstream in setup_l1_models.R
#' @param mr_files an optional character vector of NIfTI filenames used in l1 analysis.
#'   Prefer to pass these via the build_design_matrix object in $run_4d_files
#'
#' @importFrom checkmate assert_class assert_string assert_character assert_file_exists
#' @importFrom lgr get_logger
#' @importFrom parallel clusterApply stopCluster makeForkCluster
#' @author Michael Hallquist
#' @export
#' 
fsl_l1_model <- function(id=NULL, d_obj, gpa, model_name=NULL, mr_files=NULL, nvoxels=NULL, execute_feat=FALSE, lg=NULL) {
  checkmate::assert_class(gpa, "glm_pipeline_arguments")
  checkmate::assert_class(d_obj, "bdm")
  checkmate::assert_string(model_name) #single string

  if (is.null(lg)) { lg <- lgr::get_logger("glm_pipeline/fsl_l1_setup") }
  if (!is.null(d_obj$run_4d_files)) {
    lg$debug("Using internal NIfTI files (run_4d_files) within d_obj for Feat level 1 setup")
    mr_files <- d_obj$run_4d_files
  }

  stopifnot(length(mr_files) == length(d_obj$run_volumes)) #need these to align
  checkmate::assert_character(mr_files, null.ok=FALSE)
  checkmate::assert_file_exists(mr_files) #all exist
  
  stopifnot(model_name %in% names(gpa$l1_models$models))
 
  #TODO use system.file to read from R package installation dir
  fsfTemplate <- readLines(file.path(gpa$pipeline_home, "inst", "feat_lvl1_nparam_template.fsf"))  
  
  #note: normalizePath will fail to evaluate properly if directory does not exist
  fsl_run_output_dir <- file.path(normalizePath(file.path(dirname(mr_files[1L]), "..")), gpa$l1_models$models[[model_name]]$outdir)

  l1_contrasts <- gpa$l1_models$models[[model_name]]$contrasts #contrast matrix for this model
  regressors <- gpa$l1_models$models[[model_name]]$model_regressors #names of regressors in design matrix for this model
  
  if (dir.exists(fsl_run_output_dir) && file.exists(file.path(fsl_run_output_dir, "feat_l1_inputs.rds")) && isFALSE(gpa$force_l1_creation)) {
    lg$info("%s exists. Skipping l1 fsf setup in fsl_l1_model().", fsl_run_output_dir)
    subj_l1_spec <- readRDS(file.path(fsl_run_output_dir, "feat_l1_inputs.rds"))
  }

  lg$info("Create l1 fsl_run_output_dir: %s", fsl_run_output_dir)
  dir.create(fsl_run_output_dir, showWarnings=FALSE) #one directory up from a given run
  timingdir <- file.path(fsl_run_output_dir, "timing_files")

  feat_l1_df <- data.frame(id=id, run=d_obj$runs_to_output, run_volumes=d_obj$run_volumes, mr_files=mr_files, model=model_name, feat_file=NA_character_)
  allFeatFiles <- c()
  
  #FSL computes first-level models on individual runs
  for (rr in seq_along(mr_files)) {
    lg$info("Creating FSF for file: %s", mr_files[rr])
    thisTemplate <- fsfTemplate #start with default copy of template for this run
    
    all_confounds_mat <- c()
    if (!is.null(gpa$confound_settings$l1_confound_regressors)) {
      #handle setup of confound regressors -- read motion file
      if (!is.null(gpa$confound_settings$motion_params_file)) {
        motion_file <- file.path(normalizePath(file.path(dirname(mr_files[rr]), gpa$confound_settings$motion_params_file)))
        if (checkmate::test_file_exists(motion_file)) {
          mot_mat <- generate_motion_regressors(motion_file, col.names=gpa$confound_settings$motion_params_columns,
            regressors=gpa$confound_settings$l1_confound_regressors, drop_volumes=gpa$drop_volumes, last_volume=run_volumes[rr])
          all_confounds_mat <- cbind(all_confounds_mat, mot_mat)
        } else {
          lg$warn("Cannot locate motion parameters file %s", motion_file)
        }
      }

      if (!is.null(gpa$confound_settings$confound_file)) {
        confound_file <- file.path(normalizePath(file.path(dirname(mr_files[rr]), gpa$confound_settings$confound_file)))
        if (checkmate::test_file_exists(confound_file)) {
          #read in file and handle it
          confounds <- data.table::fread(confound_file, col.names=gpa$confound_settings$confound_columns)
          confounds_present <- intersect(gpa$confound_settings$l1_confound_regressors, names(confounds))
          confound_mat <- confounds[(1+gpa$drop_volumes):run_volumes[rr], ..confounds_present]
          missing_cols <- setdiff(gpa$confound_settings$l1_confound_regressors, unique(names(mot_mat, names(confounds))))
          if (length(missing_cols) > 0L) {
            lg$warn("Cannot find confound column: %s in file: %s", missing_cols, confound_file)
          }

          if (!is.null(all_confounds_mat)) { stopifnot(nrow(all_confounds_mat) ==  nrow(confound_mat)) } #error on mismatching time series length (rows)
          all_confounds_mat <- cbind(all_confounds_mat, confound_mat)          
        } else {
          lg$warn("Cannot locate confound file %s", confound_file)
        }
      }

      outfile <- file.path(fsl_run_output_dir, paste0("run", feat_l1_df$run[rr], "_confounds.txt"))
      write.table(all_confounds_mat, file=outfile, col.names=FALSE, row.names=FALSE)
      thisTemplate <- gsub(".CONFOUNDS.", outfile, thisTemplate, fixed=TRUE)
    } else { #disable confounds
      thisTemplate <- gsub("set fmri(confoundevs) 1", "set fmri(confoundevs) 0", thisTemplate, fixed=TRUE) #disable
      thisTemplate <- gsub(".CONFOUNDS.", "", thisTemplate, fixed=TRUE)
    }

    # search and replace within fsf file for appropriate sections
    # .OUTPUTDIR. is the feat output location
    # .NVOL. is the number of volumes in the run
    # .FUNCTIONAL. is the fmri data to process (sans extension)
    # .CONFOUNDS. is the confounds file for GLM
    # .TR. is the sequence TR in seconds

    thisTemplate <- gsub(".OUTPUTDIR.", file.path(fsl_run_output_dir, paste0("FEAT_LVL1_run", feat_l1_df$run[rr])), thisTemplate, fixed=TRUE)
    thisTemplate <- gsub(".NVOL.", d_obj$run_volumes[rr], thisTemplate, fixed=TRUE)
    thisTemplate <- gsub(".FUNCTIONAL.", gsub(".nii(.gz)*$", "", mr_files[rr]), thisTemplate, fixed=TRUE)
    thisTemplate <- gsub(".TR.", d_obj$tr, thisTemplate, fixed=TRUE)

    #handle additional custom feat level 1 fields in fsf syntax    
    if (!is.null(gpa$additional$feat_l1_args)) {
      for (ii in seq_along(gpa$additional$feat_l1_args)) {
        this_name <- names(gpa$additional$feat_l1_args)[ii]
        this_value <- gpa$additional$feat_l1_args[[ii]]
        if (length(this_value) > 1L) {
          lg$warn("feat_l1_args: Cannot handle settings with multiple values: %s. Skipping out.", this_name)
          next
        } else {
          lg$debug("Adding custom feat l1 setting: %s = %s", this_name, this_value)
          if (any(grepl(paste0("set fmri(", this_name, ")"), thisTemplate, fixed=TRUE))) {
            lg$debug("Substituting existing value of feat l1 setting: %s", this_name)
            thisTemplate <- gsub("(set fmri\\s*\\(", this_name, "\\))\\s*(.*)", paste0("\\1 ", this_value), perl=TRUE)
          } else {
            thisTemplate <- c(thisTemplate, paste0("set fmri(", this_name, ") ", this_value))
          }
        }
      }
    }
    
    if (isTRUE(gpa$use_preconvolve)) {
      lg$info("Using preconvolved regressors in Feat level 1 analysis")
      #generate ev syntax

      #add common ingredients for preconvolved regressors
      regressors <- lapply(regressors, function(x) {
        list(name=x, waveform="custom_1", convolution="none",
          tempfilt=1, timing_file=file.path(timingdir, paste0("run", feat_l1_df$run[rr], "_", x, ".1D")))
      })

      lg$debug("dependlab::generate_fsf_lvl1_ev_syntax")
      ev_syn <- dependlab::generate_fsf_lvl1_ev_syntax(regressors)

      #creation of l1 contrast matrices, including the diagonal contrasts, now abstracted to finalize_pipeline_configuration.R
      #thus, l1_contrasts is already a contrast matrix ready to be passed to the generate_fsf_contrast_syntax function
      lg$debug("dependlab::generate_fsf_contrast_syntax")
      cmat_syn <- dependlab::generate_fsf_contrast_syntax(l1_contrasts)

      #combine all syntax
      thisTemplate <- c(thisTemplate, ev_syn, cmat_syn)
    } else {
      #TODO -- add back in standard 3-column FSL timing
      lg$error("No support for FSL-internal convolved yet")
      stop("cannot use FSL internal timing files right this moment...")
    }
    
    featFile <- file.path(fsl_run_output_dir, paste0("FEAT_LVL1_run", feat_l1_df$run[rr], ".fsf"))
    feat_l1_df$feat_file[rr] <- featFile
    
    #skip re-creation of FSF and do not run below unless force_l1_creation==TRUE
    if (file.exists(featFile) && isFALSE(gpa$force_l1_creation)) {
      lg$info("Skipping existing feat fsf file: %s", featFile)
      next
    }

    lg$info("Writing l1 fsf file: %s", featFile)
    cat(thisTemplate, file=featFile, sep="\n")
    
    allFeatFiles <- c(allFeatFiles, featFile)
  }

  #if execute_feat is TRUE, execute feat on each fsf files at this stage, using an 8-node socket cluster (since we have 8 runs)
  #if execute_feat is FALSE, just create the fsf files but don't execute the analysis
  if (isTRUE(execute_feat) && length(allFeatFiles) > 0L) {
    require(parallel)
    nnodes <- min(length(allFeatFiles), parallel::detectCores())
    lg$info("Starting fork cluster with %d workers", nnodes)
    cl_fork <- makeForkCluster(nnodes=nnodes)
    runfeat <- function(fsf) {
      runname <- basename(fsf)
      runFSLCommand(paste("feat", fsf), stdout=file.path(dirname(fsf), paste0("feat_stdout_", runname)),
        stderr=file.path(dirname(fsf), paste0("feat_stderr_", runname)))
    }

    lg$info("Executing all subject feat files with clusterApply")
    clusterApply(cl_fork, allFeatFiles, runfeat)
    stopCluster(cl_fork)
  }

  return(feat_l1_df)
  
}
